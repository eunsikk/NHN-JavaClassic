// Source code is decompiled from a .class file using FernFlower decompiler.
package java.util;

import java.lang.reflect.Array;
import java.util.Comparators.NaturalOrderComparator;

public class Collections {
   private static final int BINARYSEARCH_THRESHOLD = 5000;
   private static final int REVERSE_THRESHOLD = 18;
   private static final int SHUFFLE_THRESHOLD = 5;
   private static final int FILL_THRESHOLD = 25;
   private static final int ROTATE_THRESHOLD = 100;
   private static final int COPY_THRESHOLD = 10;
   private static final int REPLACEALL_THRESHOLD = 11;
   private static final int INDEXOFSUBLIST_THRESHOLD = 35;
   private static Random r;
   public static final Set EMPTY_SET = new EmptySet();
   public static final List EMPTY_LIST = new EmptyList();
   public static final Map EMPTY_MAP = new EmptyMap();

   private Collections() {
   }

   public static <T extends Comparable<? super T>> void sort(List<T> list) {
      list.sort((Comparator)null);
   }

   public static <T> void sort(List<T> list, Comparator<? super T> c) {
      list.sort(c);
   }

   public static <T> int binarySearch(List<? extends Comparable<? super T>> list, T key) {
      return !(list instanceof RandomAccess) && list.size() >= 5000 ? iteratorBinarySearch(list, key) : indexedBinarySearch(list, key);
   }

   private static <T> int indexedBinarySearch(List<? extends Comparable<? super T>> list, T key) {
      int low = 0;
      int high = list.size() - 1;

      while(low <= high) {
         int mid = low + high >>> 1;
         Comparable<? super T> midVal = (Comparable)list.get(mid);
         int cmp = midVal.compareTo(key);
         if (cmp < 0) {
            low = mid + 1;
         } else {
            if (cmp <= 0) {
               return mid;
            }

            high = mid - 1;
         }
      }

      return -(low + 1);
   }

   private static <T> int iteratorBinarySearch(List<? extends Comparable<? super T>> list, T key) {
      int low = 0;
      int high = list.size() - 1;
      ListIterator<? extends Comparable<? super T>> i = list.listIterator();

      while(low <= high) {
         int mid = low + high >>> 1;
         Comparable<? super T> midVal = (Comparable)get(i, mid);
         int cmp = midVal.compareTo(key);
         if (cmp < 0) {
            low = mid + 1;
         } else {
            if (cmp <= 0) {
               return mid;
            }

            high = mid - 1;
         }
      }

      return -(low + 1);
   }

   private static <T> T get(ListIterator<? extends T> i, int index) {
      T obj = null;
      int pos = i.nextIndex();
      if (pos <= index) {
         do {
            obj = i.next();
         } while(pos++ < index);
      } else {
         do {
            obj = i.previous();
            --pos;
         } while(pos > index);
      }

      return obj;
   }

   public static <T> int binarySearch(List<? extends T> list, T key, Comparator<? super T> c) {
      if (c == null) {
         return binarySearch(list, key);
      } else {
         return !(list instanceof RandomAccess) && list.size() >= 5000 ? iteratorBinarySearch(list, key, c) : indexedBinarySearch(list, key, c);
      }
   }

   private static <T> int indexedBinarySearch(List<? extends T> l, T key, Comparator<? super T> c) {
      int low = 0;
      int high = l.size() - 1;

      while(low <= high) {
         int mid = low + high >>> 1;
         T midVal = l.get(mid);
         int cmp = c.compare(midVal, key);
         if (cmp < 0) {
            low = mid + 1;
         } else {
            if (cmp <= 0) {
               return mid;
            }

            high = mid - 1;
         }
      }

      return -(low + 1);
   }

   private static <T> int iteratorBinarySearch(List<? extends T> l, T key, Comparator<? super T> c) {
      int low = 0;
      int high = l.size() - 1;
      ListIterator<? extends T> i = l.listIterator();

      while(low <= high) {
         int mid = low + high >>> 1;
         T midVal = get(i, mid);
         int cmp = c.compare(midVal, key);
         if (cmp < 0) {
            low = mid + 1;
         } else {
            if (cmp <= 0) {
               return mid;
            }

            high = mid - 1;
         }
      }

      return -(low + 1);
   }

   public static void reverse(List<?> list) {
      int size = list.size();
      int j;
      if (size >= 18 && !(list instanceof RandomAccess)) {
         ListIterator fwd = list.listIterator();
         ListIterator rev = list.listIterator(size);
         j = 0;

         for(int mid = list.size() >> 1; j < mid; ++j) {
            Object tmp = fwd.next();
            fwd.set(rev.previous());
            rev.set(tmp);
         }
      } else {
         int i = 0;
         int mid = size >> 1;

         for(j = size - 1; i < mid; --j) {
            swap(list, i, j);
            ++i;
         }
      }

   }

   public static void shuffle(List<?> list) {
      Random rnd = r;
      if (rnd == null) {
         r = rnd = new Random();
      }

      shuffle(list, rnd);
   }

   public static void shuffle(List<?> list, Random rnd) {
      int size = list.size();
      if (size >= 5 && !(list instanceof RandomAccess)) {
         Object[] arr = list.toArray();

         for(int i = size; i > 1; --i) {
            swap(arr, i - 1, rnd.nextInt(i));
         }

         ListIterator it = list.listIterator();
         Object[] var5 = arr;
         int var6 = arr.length;

         for(int var7 = 0; var7 < var6; ++var7) {
            Object e = var5[var7];
            it.next();
            it.set(e);
         }
      } else {
         for(int i = size; i > 1; --i) {
            swap(list, i - 1, rnd.nextInt(i));
         }
      }

   }

   public static void swap(List<?> list, int i, int j) {
      list.set(i, list.set(j, list.get(i)));
   }

   private static void swap(Object[] arr, int i, int j) {
      Object tmp = arr[i];
      arr[i] = arr[j];
      arr[j] = tmp;
   }

   public static <T> void fill(List<? super T> list, T obj) {
      int size = list.size();
      if (size >= 25 && !(list instanceof RandomAccess)) {
         ListIterator<? super T> itr = list.listIterator();

         for(int i = 0; i < size; ++i) {
            itr.next();
            itr.set(obj);
         }
      } else {
         for(int i = 0; i < size; ++i) {
            list.set(i, obj);
         }
      }

   }

   public static <T> void copy(List<? super T> dest, List<? extends T> src) {
      int srcSize = src.size();
      if (srcSize > dest.size()) {
         throw new IndexOutOfBoundsException("Source does not fit in dest");
      } else {
         if (srcSize < 10 || src instanceof RandomAccess && dest instanceof RandomAccess) {
            for(int i = 0; i < srcSize; ++i) {
               dest.set(i, src.get(i));
            }
         } else {
            ListIterator<? super T> di = dest.listIterator();
            ListIterator<? extends T> si = src.listIterator();

            for(int i = 0; i < srcSize; ++i) {
               di.next();
               di.set(si.next());
            }
         }

      }
   }

   public static <T extends Object & Comparable<? super T>> T min(Collection<? extends T> coll) {
      Iterator<? extends T> i = coll.iterator();
      T candidate = i.next();

      while(i.hasNext()) {
         T next = i.next();
         if (((Comparable)next).compareTo(candidate) < 0) {
            candidate = next;
         }
      }

      return candidate;
   }

   public static <T> T min(Collection<? extends T> coll, Comparator<? super T> comp) {
      if (comp == null) {
         return min(coll);
      } else {
         Iterator<? extends T> i = coll.iterator();
         T candidate = i.next();

         while(i.hasNext()) {
            T next = i.next();
            if (comp.compare(next, candidate) < 0) {
               candidate = next;
            }
         }

         return candidate;
      }
   }

   public static <T extends Object & Comparable<? super T>> T max(Collection<? extends T> coll) {
      Iterator<? extends T> i = coll.iterator();
      T candidate = i.next();

      while(i.hasNext()) {
         T next = i.next();
         if (((Comparable)next).compareTo(candidate) > 0) {
            candidate = next;
         }
      }

      return candidate;
   }

   public static <T> T max(Collection<? extends T> coll, Comparator<? super T> comp) {
      if (comp == null) {
         return max(coll);
      } else {
         Iterator<? extends T> i = coll.iterator();
         T candidate = i.next();

         while(i.hasNext()) {
            T next = i.next();
            if (comp.compare(next, candidate) > 0) {
               candidate = next;
            }
         }

         return candidate;
      }
   }

   public static void rotate(List<?> list, int distance) {
      if (!(list instanceof RandomAccess) && list.size() >= 100) {
         rotate2(list, distance);
      } else {
         rotate1(list, distance);
      }

   }

   private static <T> void rotate1(List<T> list, int distance) {
      int size = list.size();
      if (size != 0) {
         distance %= size;
         if (distance < 0) {
            distance += size;
         }

         if (distance != 0) {
            int cycleStart = 0;

            for(int nMoved = 0; nMoved != size; ++cycleStart) {
               T displaced = list.get(cycleStart);
               int i = cycleStart;

               do {
                  i += distance;
                  if (i >= size) {
                     i -= size;
                  }

                  displaced = list.set(i, displaced);
                  ++nMoved;
               } while(i != cycleStart);
            }

         }
      }
   }

   private static void rotate2(List<?> list, int distance) {
      int size = list.size();
      if (size != 0) {
         int mid = -distance % size;
         if (mid < 0) {
            mid += size;
         }

         if (mid != 0) {
            reverse(list.subList(0, mid));
            reverse(list.subList(mid, size));
            reverse(list);
         }
      }
   }

   public static <T> boolean replaceAll(List<T> list, T oldVal, T newVal) {
      boolean result = false;
      int size = list.size();
      if (size >= 11 && !(list instanceof RandomAccess)) {
         ListIterator<T> itr = list.listIterator();
         int i;
         if (oldVal == null) {
            for(i = 0; i < size; ++i) {
               if (itr.next() == null) {
                  itr.set(newVal);
                  result = true;
               }
            }
         } else {
            for(i = 0; i < size; ++i) {
               if (oldVal.equals(itr.next())) {
                  itr.set(newVal);
                  result = true;
               }
            }
         }
      } else {
         int i;
         if (oldVal == null) {
            for(i = 0; i < size; ++i) {
               if (list.get(i) == null) {
                  list.set(i, newVal);
                  result = true;
               }
            }
         } else {
            for(i = 0; i < size; ++i) {
               if (oldVal.equals(list.get(i))) {
                  list.set(i, newVal);
                  result = true;
               }
            }
         }
      }

      return result;
   }

   public static int indexOfSubList(List<?> source, List<?> target) {
      int sourceSize = source.size();
      int targetSize = target.size();
      int maxCandidate = sourceSize - targetSize;
      int candidate;
      if (sourceSize < 35 || source instanceof RandomAccess && target instanceof RandomAccess) {
         label60:
         for(int candidate = 0; candidate <= maxCandidate; ++candidate) {
            candidate = 0;

            for(int j = candidate; candidate < targetSize; ++j) {
               if (!eq(target.get(candidate), source.get(j))) {
                  continue label60;
               }

               ++candidate;
            }

            return candidate;
         }
      } else {
         ListIterator<?> si = source.listIterator();

         label48:
         for(candidate = 0; candidate <= maxCandidate; ++candidate) {
            ListIterator<?> ti = target.listIterator();

            for(int i = 0; i < targetSize; ++i) {
               if (!eq(ti.next(), si.next())) {
                  for(int j = 0; j < i; ++j) {
                     si.previous();
                  }
                  continue label48;
               }
            }

            return candidate;
         }
      }

      return -1;
   }

   public static int lastIndexOfSubList(List<?> source, List<?> target) {
      int sourceSize = source.size();
      int targetSize = target.size();
      int maxCandidate = sourceSize - targetSize;
      int candidate;
      if (sourceSize >= 35 && !(source instanceof RandomAccess)) {
         if (maxCandidate < 0) {
            return -1;
         }

         ListIterator<?> si = source.listIterator(maxCandidate);

         label54:
         for(candidate = maxCandidate; candidate >= 0; --candidate) {
            ListIterator<?> ti = target.listIterator();

            for(int i = 0; i < targetSize; ++i) {
               if (!eq(ti.next(), si.next())) {
                  if (candidate != 0) {
                     for(int j = 0; j <= i + 1; ++j) {
                        si.previous();
                     }
                  }
                  continue label54;
               }
            }

            return candidate;
         }
      } else {
         label66:
         for(int candidate = maxCandidate; candidate >= 0; --candidate) {
            candidate = 0;

            for(int j = candidate; candidate < targetSize; ++j) {
               if (!eq(target.get(candidate), source.get(j))) {
                  continue label66;
               }

               ++candidate;
            }

            return candidate;
         }
      }

      return -1;
   }

   public static <T> Collection<T> unmodifiableCollection(Collection<? extends T> c) {
      return new UnmodifiableCollection(c);
   }

   public static <T> Set<T> unmodifiableSet(Set<? extends T> s) {
      return new UnmodifiableSet(s);
   }

   public static <T> SortedSet<T> unmodifiableSortedSet(SortedSet<T> s) {
      return new UnmodifiableSortedSet(s);
   }

   public static <T> NavigableSet<T> unmodifiableNavigableSet(NavigableSet<T> s) {
      return new UnmodifiableNavigableSet(s);
   }

   public static <T> List<T> unmodifiableList(List<? extends T> list) {
      return (List)(list instanceof RandomAccess ? new UnmodifiableRandomAccessList(list) : new UnmodifiableList(list));
   }

   public static <K, V> Map<K, V> unmodifiableMap(Map<? extends K, ? extends V> m) {
      return new UnmodifiableMap(m);
   }

   public static <K, V> SortedMap<K, V> unmodifiableSortedMap(SortedMap<K, ? extends V> m) {
      return new UnmodifiableSortedMap(m);
   }

   public static <K, V> NavigableMap<K, V> unmodifiableNavigableMap(NavigableMap<K, ? extends V> m) {
      return new UnmodifiableNavigableMap(m);
   }

   public static <T> Collection<T> synchronizedCollection(Collection<T> c) {
      return new SynchronizedCollection(c);
   }

   static <T> Collection<T> synchronizedCollection(Collection<T> c, Object mutex) {
      return new SynchronizedCollection(c, mutex);
   }

   public static <T> Set<T> synchronizedSet(Set<T> s) {
      return new SynchronizedSet(s);
   }

   static <T> Set<T> synchronizedSet(Set<T> s, Object mutex) {
      return new SynchronizedSet(s, mutex);
   }

   public static <T> SortedSet<T> synchronizedSortedSet(SortedSet<T> s) {
      return new SynchronizedSortedSet(s);
   }

   public static <T> NavigableSet<T> synchronizedNavigableSet(NavigableSet<T> s) {
      return new SynchronizedNavigableSet(s);
   }

   public static <T> List<T> synchronizedList(List<T> list) {
      return (List)(list instanceof RandomAccess ? new SynchronizedRandomAccessList(list) : new SynchronizedList(list));
   }

   static <T> List<T> synchronizedList(List<T> list, Object mutex) {
      return (List)(list instanceof RandomAccess ? new SynchronizedRandomAccessList(list, mutex) : new SynchronizedList(list, mutex));
   }

   public static <K, V> Map<K, V> synchronizedMap(Map<K, V> m) {
      return new SynchronizedMap(m);
   }

   public static <K, V> SortedMap<K, V> synchronizedSortedMap(SortedMap<K, V> m) {
      return new SynchronizedSortedMap(m);
   }

   public static <K, V> NavigableMap<K, V> synchronizedNavigableMap(NavigableMap<K, V> m) {
      return new SynchronizedNavigableMap(m);
   }

   public static <E> Collection<E> checkedCollection(Collection<E> c, Class<E> type) {
      return new CheckedCollection(c, type);
   }

   static <T> T[] zeroLengthArray(Class<T> type) {
      return (Object[])Array.newInstance(type, 0);
   }

   public static <E> Queue<E> checkedQueue(Queue<E> queue, Class<E> type) {
      return new CheckedQueue(queue, type);
   }

   public static <E> Set<E> checkedSet(Set<E> s, Class<E> type) {
      return new CheckedSet(s, type);
   }

   public static <E> SortedSet<E> checkedSortedSet(SortedSet<E> s, Class<E> type) {
      return new CheckedSortedSet(s, type);
   }

   public static <E> NavigableSet<E> checkedNavigableSet(NavigableSet<E> s, Class<E> type) {
      return new CheckedNavigableSet(s, type);
   }

   public static <E> List<E> checkedList(List<E> list, Class<E> type) {
      return (List)(list instanceof RandomAccess ? new CheckedRandomAccessList(list, type) : new CheckedList(list, type));
   }

   public static <K, V> Map<K, V> checkedMap(Map<K, V> m, Class<K> keyType, Class<V> valueType) {
      return new CheckedMap(m, keyType, valueType);
   }

   public static <K, V> SortedMap<K, V> checkedSortedMap(SortedMap<K, V> m, Class<K> keyType, Class<V> valueType) {
      return new CheckedSortedMap(m, keyType, valueType);
   }

   public static <K, V> NavigableMap<K, V> checkedNavigableMap(NavigableMap<K, V> m, Class<K> keyType, Class<V> valueType) {
      return new CheckedNavigableMap(m, keyType, valueType);
   }

   public static <T> Iterator<T> emptyIterator() {
      return java.util.Collections.EmptyIterator.EMPTY_ITERATOR;
   }

   public static <T> ListIterator<T> emptyListIterator() {
      return java.util.Collections.EmptyListIterator.EMPTY_ITERATOR;
   }

   public static <T> Enumeration<T> emptyEnumeration() {
      return java.util.Collections.EmptyEnumeration.EMPTY_ENUMERATION;
   }

   public static final <T> Set<T> emptySet() {
      return EMPTY_SET;
   }

   public static <E> SortedSet<E> emptySortedSet() {
      return java.util.Collections.UnmodifiableNavigableSet.EMPTY_NAVIGABLE_SET;
   }

   public static <E> NavigableSet<E> emptyNavigableSet() {
      return java.util.Collections.UnmodifiableNavigableSet.EMPTY_NAVIGABLE_SET;
   }

   public static final <T> List<T> emptyList() {
      return EMPTY_LIST;
   }

   public static final <K, V> Map<K, V> emptyMap() {
      return EMPTY_MAP;
   }

   public static final <K, V> SortedMap<K, V> emptySortedMap() {
      return java.util.Collections.UnmodifiableNavigableMap.EMPTY_NAVIGABLE_MAP;
   }

   public static final <K, V> NavigableMap<K, V> emptyNavigableMap() {
      return java.util.Collections.UnmodifiableNavigableMap.EMPTY_NAVIGABLE_MAP;
   }

   public static <T> Set<T> singleton(T o) {
      return new SingletonSet(o);
   }

   static <E> Iterator<E> singletonIterator(E e) {
      return new 1(e);
   }

   static <T> Spliterator<T> singletonSpliterator(T element) {
      return new 2(element);
   }

   public static <T> List<T> singletonList(T o) {
      return new SingletonList(o);
   }

   public static <K, V> Map<K, V> singletonMap(K key, V value) {
      return new SingletonMap(key, value);
   }

   public static <T> List<T> nCopies(int n, T o) {
      if (n < 0) {
         throw new IllegalArgumentException("List length = " + n);
      } else {
         return new CopiesList(n, o);
      }
   }

   public static <T> Comparator<T> reverseOrder() {
      return java.util.Collections.ReverseComparator.REVERSE_ORDER;
   }

   public static <T> Comparator<T> reverseOrder(Comparator<T> cmp) {
      if (cmp == null) {
         return java.util.Collections.ReverseComparator.REVERSE_ORDER;
      } else if (cmp == java.util.Collections.ReverseComparator.REVERSE_ORDER) {
         return NaturalOrderComparator.INSTANCE;
      } else if (cmp == NaturalOrderComparator.INSTANCE) {
         return java.util.Collections.ReverseComparator.REVERSE_ORDER;
      } else {
         return (Comparator)(cmp instanceof ReverseComparator2 ? ((ReverseComparator2)cmp).cmp : new ReverseComparator2(cmp));
      }
   }

   public static <T> Enumeration<T> enumeration(Collection<T> c) {
      return new 3(c);
   }

   public static <T> ArrayList<T> list(Enumeration<T> e) {
      ArrayList<T> l = new ArrayList();

      while(e.hasMoreElements()) {
         l.add(e.nextElement());
      }

      return l;
   }

   static boolean eq(Object o1, Object o2) {
      return o1 == null ? o2 == null : o1.equals(o2);
   }

   public static int frequency(Collection<?> c, Object o) {
      int result = 0;
      Iterator var3;
      Object e;
      if (o == null) {
         var3 = c.iterator();

         while(var3.hasNext()) {
            e = var3.next();
            if (e == null) {
               ++result;
            }
         }
      } else {
         var3 = c.iterator();

         while(var3.hasNext()) {
            e = var3.next();
            if (o.equals(e)) {
               ++result;
            }
         }
      }

      return result;
   }

   public static boolean disjoint(Collection<?> c1, Collection<?> c2) {
      Collection<?> contains = c2;
      Collection<?> iterate = c1;
      if (c1 instanceof Set) {
         iterate = c2;
         contains = c1;
      } else if (!(c2 instanceof Set)) {
         int c1size = c1.size();
         int c2size = c2.size();
         if (c1size == 0 || c2size == 0) {
            return true;
         }

         if (c1size > c2size) {
            iterate = c2;
            contains = c1;
         }
      }

      Iterator var6 = iterate.iterator();

      Object e;
      do {
         if (!var6.hasNext()) {
            return true;
         }

         e = var6.next();
      } while(!contains.contains(e));

      return false;
   }

   @SafeVarargs
   public static <T> boolean addAll(Collection<? super T> c, T... elements) {
      boolean result = false;
      Object[] var3 = elements;
      int var4 = elements.length;

      for(int var5 = 0; var5 < var4; ++var5) {
         T element = var3[var5];
         result |= c.add(element);
      }

      return result;
   }

   public static <E> Set<E> newSetFromMap(Map<E, Boolean> map) {
      return new SetFromMap(map);
   }

   public static <T> Queue<T> asLifoQueue(Deque<T> deque) {
      return new AsLIFOQueue((Deque)Objects.requireNonNull(deque));
   }
}
